
\begin{section}{Ejercicio 5}

	%Resultados y análisis de la corrida del scheduler \cmd{RR} en los tasks sets dados por la cátedra.
	%Aclaración: Para realizar el análisis se utilizará el quantum predeterminado dado por la materia.
	%Se implementó para obtener resultados más realistas, un retardo de dos unidades de tiempo al final de cada quantum consideradas como "context switch".

	El tiempo de espera promedio para \cmd{ts1..4} con un \kw{quantum} de 5 unidades de tiempo está entre 255 y 309 unidades de tiempo. Vemos que el tiempo de espera es alto. A pesar de que se desconoce la funcionalidad específica de las tareas que comprenden estos \kw{tasksets}, podemos notar algunas consideraciones. Mantener este valor bajo de espera promedio nos serviría si se necesita tener algún tipo de interacción con el usuario, notar que este valor de \kw{quantum} provoca que continuamente se esté haciendo cambios de contextos, con un costo importante debido a la gran cantidad de \kw{task switch} que puede provocar. El valor del \kw{quantum} debe analizarse con gran detalle sabiendo la carga y cantidad de trabajos que tendría el \cmd{CPU} corriendo con \cmd{Round Robin}. Si este \kw{quantum} disminuye aumenta el porcentaje de tiempo que gasta realizando cambio de contexto en pos de una sensación de fluidez si se trabaja en entorno interactivos, pero si se aumenta considerablemente nos acercamos más a tener un modelo de scheduler \cmd{FCFS} (el cual aumentaría el rendimiento si tuviéramos procesos \kw{batch}). Notar que en los tasks analizados si el \kw{quantum} aumenta, el tiempo de espera media disminuye.	Al igual que con el análisis del ejercicio cuatro, hemos notado la importancia de saber qué procesos son los que se están utilizando, para que el \kw{scheduler} sea el más adecuando posible. 
	
	En los \kw{tasksets} 4 y 5, tenemos waiting times de 154 unidades y 153 respectivamente pero no se está modelando el problema original que consistía en iniciar una base de datos, iniciar el servidor, permitir que clientes se conecten; y una vez desconectados todos cerrar el servidor y la base de datos. \kw{Round Robin} otorga un \kw{quantum} predefinido a cada proceso, y como en este caso, inicializar el servidor y base de datos cuesta más unidades de las otorgadas, se completan después que cliente comienza a ejecutarse. Una buena solución a este problema, hubiera sido ejecutar de forma \cmd{FCFS} todos los procesos que inicializan el server, pudiendo así poder rotar entre los distintos clientes con política \code{Round Robin}, con un \kw{quantum} suficientemente bueno para dar la sensación de continuidad y además no derrochar excesiva cantidad de tiempo realizando cambios de contexto. Notar que una vez que todos los usuarios hayan terminado de realizar sus tareas, debería aplicarse nuevamente un scheduler \cmd{FCFS} para una correcta finalización del server y la base de datos.

\end{section}

